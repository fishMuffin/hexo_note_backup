---
title: 设计模式入门一
date: 2020-07-13 08:47:40
tags: [java,GoF]
---

# 设计模式

​		设计模式是前人结合自己的开发经验总结出来的,是一些通用的套路,可以提高代码的可复用性,可维护性,稳健性,可读性的解决方案.设计模式的本质是面向对象的实际运用,是对类的封装性,继承性和多态性以及类的关联和组合关系的充分理解.

​		对于大型项目开发或者框架设计,设计模式往往发挥着至关重要的作用.

## 设计模式的产生背景

​		设计模式的概念是来自于建筑领域的.

​		1995年,"四人组"(Gang of four)联合出版了《设计模式:可复用面向对象软件的基础》(Design Patterns:Elements of Reusable Object-Oriented Software).书中包含了23种设计模式,时至今日,狭义上的设计模式指的就是这23中设计模式.



## 设计模式的概念

​		软件设计模式(Software Design Pattern),又称设计模式,是一套被反复检验求证过的,分门别类归纳总结的代码设计经验.它描述了软件设计过程中的一些不断重复发生的问题,以及该问题的解决方案.其目的是为了提高代码的可重用性,代码的可读性和代码的可靠性.

## 学习设计模式的意义

​		设计模式的本质是面向对象设计原则的实际运用,是对类的封装性,继承性和多态性以及类的关联关系和组合关系的充分理解.合理正确地使用设计模式有很多优点:
​		可以提高编程人员的思维能力,编程能力和设计能力
​		使设计的代码可重用性高,可读性强,可靠性高,灵活性好,可维护性强.
​		使得程序设计更加标准化,代码编制更加工程化,使软件开发效率大大提高,从而缩短软件的开发周期,降低风险.

## GoF23中设计模式的分类和功能

### 根据目的来分

| 名称       | 描述                                                         | 例子                                                         |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 创建型模式 | 用于描述"怎么创建对象",主要的特点是"将对象的创建与使用分离"  | 共5种:单例,原型,工厂方法,抽象工厂,建造者                     |
| 结构型模式 | 用于描述如果将类或对象按某种布局组成更大的结构               | 共7种:代理,适配器,桥接,装饰,外观,享元,组合                   |
| 行为型模式 | 用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务,以及怎样分配职责. | 共11种:模板方法,策略,命令,职责链,状态,观察者,中介者,迭代器,访问者,备忘录,解释器 |

### 按照作用范围来分

| 名称     | 描述                                                         | 例子                                      |
| -------- | ------------------------------------------------------------ | ----------------------------------------- |
| 类模式   | 用于处理类与字类之间的关系,这些关系通过继承来建立,是静态的,在编译时刻便确定下来了. | 共4种:工厂方法,(类)适配器,模板方法,解释器 |
| 对象模式 | 用于处理对象之间的关系,这些关系可以通过组合或聚合来实现,在运行时刻是可以变化的,更具动态性. | 除了以上四种                              |



### 综合分类表

| 范围\目的 | 创建型模式                | 结构型模式                                 | 行为型模式                                               |
| --------- | ------------------------- | ------------------------------------------ | -------------------------------------------------------- |
| 类模式    | 工厂方法                  | (类)适配器                                 | 模板方法,解释器                                          |
| 对象模式  | 单例,原型,抽象工厂,建造者 | 代理,(对象)适配器,桥接,装饰,外观,享元,组合 | 策略,命令,责任链,状态,观察者,中介者,迭代器,访问者,备忘录 |

### GoF23中设计模式功能

| 名称         | 英文                    | 功能介绍                                                     |
| ------------ | ----------------------- | ------------------------------------------------------------ |
| 单例模式     | SIngleton               | 某个类只能生成一个实例,该类提供一个全局访问点供外部获取该实例,拓展是有限多例模式. |
| 原型模式     | Prototype               | 将一个对象作为原型,通过对其进行复制而克隆出多个和原型类似的新实例 |
| 工厂方法模式 | Factory Method          | 定义一个用于创建产品的接口,由子类决定生产什么产品            |
| 抽象工厂模式 | Abstract Factory        | 提供一个创建产品族的接口,其每个子类可以生产一系列相关产品    |
| 建造者模式   | Builder                 | 将一个复杂对象分解成多个相对简单的部分,然后根据不同需要分别创建它们,最后构建成该复杂对象. |
| 代理模式     | Proxy                   | 为某对象提供一种代理以控制对该对象的访问.即客户端通过代理间接访问该对象,从而限制,增强或修改该对象的一些特征. |
| 适配器模式   | Adapter                 | 将一个类的接口转换成客户希望的另外一个接口,使得原本由于接口不兼容而不能一起工作的那些类一起工作. |
| 桥接模式     | Bridge                  | 将抽象与现实分离,使它们可以独立变化.它是用组合关系代替集成关系来实现,从而降低了抽象和实现这两个可变维度的耦合度. |
| 装饰模式     | Decorator               | 动态的给对象增加一些职责,即增加其额外的功能.                 |
| 外观模式     | Facade                  | 为多个复杂的子系统提供一个一致的接口,使这些子系统更加容易被访问. |
| 享元模式     | Flyweight               | 运用共享技术来有效地支持大量细粒度对象的复用.                |
| 组合模式     | Composite               | 将对象组合成树状层次结构,使用户对单个对象和组合对象具有一致的访问型性. |
| 模板方法模式 | Templete Method         | 定义一个操作中的算法骨架,而将算法的一些步骤延迟到子类中,使得子类可以不改变该算法结构的情况下冲定义该算法的某些特定步骤. |
| 策略模式     | Strategy                | 定义了一系列算法,并将每个算法封装起来,使它们可以相互替换,且算法的改变不会影响使用算法的客户. |
| 命令模式     | Command                 | 将一个请求封装为一个对象,使发出请求的责任和执行请求的责任分开. |
| 责任链模式   | Chain of Responsibility | 把请求从链中的一个对象传到下一个对象,直到请求被响应为止.通过这种方式去除对象之间的耦合. |
| 状态模式     | State                   | 允许一个对象在其内部状态发生改变时改变其行为能力.            |
| 观察者模式   | Observer                | 多个对象间存在一对多关系,当一个对象发生改变时,把这种改变通知给其他多个对象,从而影响其他对象的行为. |
| 中介者模式   | Mediator                | 定义一个中介对象来简化原有对象之间的交互关系,降低系统中对象间的耦合度,使原有对象之间不比相互了解. |
| 迭代器模式   | Iterator                | 提供一种方法来顺序访问聚合对象中的一系列数据,而不暴露聚合对象的内部表示. |
| 访问者模式   | Visitor                 | 在不改变集合元素的前提下,为一个集合中的每个元素提供多种访问方式,即每个元素有多个访问者对象访问. |
| 备忘录模式   | Memento                 | 在不破坏封装性的前提下,获取并保存一个对象的内部状态,以便以后恢复它. |
| 解释器模式   | Interpreter             | 提供如何定义语言的文法,以及对语言句子的解释方法,即解释器.    |

